<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bill]]></title>
  <link href="http://billsion.github.io/atom.xml" rel="self"/>
  <link href="http://billsion.github.io/"/>
  <updated>2013-09-11T18:26:58+08:00</updated>
  <id>http://billsion.github.io/</id>
  <author>
    <name><![CDATA[Bill Sion]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Magento企業版Abandon Cart Reminder不能正常工作]]></title>
    <link href="http://billsion.github.io/blog/2013/09/11/abandon-cart-reminder-is-not-working-in-magento-enterprise-edition/"/>
    <updated>2013-09-11T18:22:00+08:00</updated>
    <id>http://billsion.github.io/blog/2013/09/11/abandon-cart-reminder-is-not-working-in-magento-enterprise-edition</id>
    <content type="html"><![CDATA[<p>在做Magento企業版開發的時候，遇到一個問題。
Abandon cart reminder 工作不正常。</p>

<h3>Abandon cart reminder 是怎樣工作的</h3>

<p>該功能是用來設置提醒那些在購物車裏還有商品沒有結賬的客戶回來結賬用，或是在心願單裏有商品的客戶趕緊將商品添加到購物車結賬。總之，這就是種促銷手段，增加用戶的黏性。</p>

<h3>但是它現在不能正常工作</h3>

<p>現在的設置條件是：</p>

<p><em>購物車為不為空並且購物車總金額也不為空，超過一天未結算。給這樣的用戶發郵件</em></p>

<p>但是，這個功能有一個先天的錯誤。它只能對符合條件的用戶發一封郵件。我理解的正常情況下，它應該對未滿足條件的用戶按照schedule的設置不停發。</p>

<p>一路跟蹤到：</p>

<p><code>app/code/core/Enterprise/Reminder/Model/Resource/Rule.php</code></p>

<p>463~464行。</p>

<p>`$select->having(&#8216;log_sent_at_max IS NULL OR (&#8217; . $findInSetSql . &#8217; AND &#8217;</p>

<pre><code>        . $_helper-&gt;getDateDiff('log_sent_at_max', $adapter-&gt;formatDate($currentDate)) . ' = 0)');`
</code></pre>

<p>最後這個<code>=0</code>便是問題所在。根據整個的SQL語句的語義：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SELECT c.customer_id, c.coupon_id, c.rule_id, r.schedule, MAX(l.sent_at) AS log_sent_at_max, MIN(l.sent_at) AS log_sent_at_min FROM enterprise_reminder_rule_coupon AS c INNER JOIN enterprise_reminder_rule AS r ON c.rule_id = r.rule_id LEFT JOIN enterprise_reminder_rule_log AS l ON c.rule_id = l.rule_id AND c.customer_id = l.customer_id WHERE (c.is_active = 1) GROUP BY c.customer_id, c.rule_id HAVING (log_sent_at_max IS NULL OR (FIND_IN_SET((TO_DAYS('2013-09-11 08:25:12') - TO_DAYS(log_sent_at_min)), schedule) AND (TO_DAYS('2013-09-11 08:25:12') - TO_DAYS(log_sent_at_max)) = 0)) LIMIT 100</span></code></pre></td></tr></table></div></figure>


<p>除了第一天未發的情況，永遠不可能等於零。如果是第一天，那麽在第一個OR的時候就TRUE了。</p>

<p>所以，這塊需要改動，將等於改為大於便可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Magento 裏 Collection 的條件代碼表]]></title>
    <link href="http://billsion.github.io/blog/2013/07/03/magento-filter-condition-codes/"/>
    <updated>2013-07-03T09:27:00+08:00</updated>
    <id>http://billsion.github.io/blog/2013/07/03/magento-filter-condition-codes</id>
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>Attribute Code </th>
<th> SQL Equivalent </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>eq             </td>
<td> =              </td>
<td>            </td>
</tr>
<tr>
<td>neq            </td>
<td> !=             </td>
<td>            </td>
</tr>
<tr>
<td>like           </td>
<td> LIKE           </td>
<td>            </td>
</tr>
<tr>
<td>nlike          </td>
<td> NOT LIKE       </td>
<td>            </td>
</tr>
<tr>
<td>in             </td>
<td> IN ( )         </td>
<td>            </td>
</tr>
<tr>
<td>nin            </td>
<td> NOT IN ( )     </td>
<td>            </td>
</tr>
<tr>
<td>is             </td>
<td> IS             </td>
<td>            </td>
</tr>
<tr>
<td>notnull        </td>
<td> IS NOT NULL    </td>
<td>            </td>
</tr>
<tr>
<td>null           </td>
<td> IS NULL        </td>
<td>            </td>
</tr>
<tr>
<td>moreq          </td>
<td> &gt;=          </td>
<td>            </td>
</tr>
<tr>
<td>gt             </td>
<td> &gt;           </td>
<td>            </td>
</tr>
<tr>
<td>lt             </td>
<td> &lt;           </td>
<td>            </td>
</tr>
<tr>
<td>gteq           </td>
<td> &gt;=          </td>
<td>            </td>
</tr>
<tr>
<td>lteq           </td>
<td> &lt;=          </td>
<td>            </td>
</tr>
<tr>
<td>finset         </td>
<td> FIND_IN_SET( ) </td>
<td>            </td>
</tr>
<tr>
<td>from           </td>
<td> &gt;=          </td>
<td> for use with dates            </td>
</tr>
<tr>
<td>to             </td>
<td> &lt;=          </td>
<td> for use with dates           </td>
</tr>
<tr>
<td>date           </td>
<td>                </td>
<td> optional flag for use with <em>from/to</em> to specify that comparison value should first be converted to a <em>date</em></td>
</tr>
<tr>
<td>datetime       </td>
<td>                </td>
<td> optional flag for use with <em>from/to</em> to specify that comparison value should first be converted to a <em>date</em></td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP裏的Foreach到底是怎麼工作的]]></title>
    <link href="http://billsion.github.io/blog/2013/06/26/how-foreach-actually-works/"/>
    <updated>2013-06-26T15:31:00+08:00</updated>
    <id>http://billsion.github.io/blog/2013/06/26/how-foreach-actually-works</id>
    <content type="html"><![CDATA[<p>本文譯自StackOverflow上的這篇<a href="http://stackoverflow.com/questions/10057671/how-foreach-actually-works," title="文章地址">文章</a></p>

<p>讓我首先聲明一下，我知道什麼是<code>foreach()</code>，它是怎麼工作的，在什麼時候使用它。</p>

<p>我的問題便是『它內部是怎麼工作的』，我不想看到諸如『是的，<code>foreach()</code>下的數組是這樣循環的』。</p>

<hr />

<p>有很長一段時間我都以為<code>foreach()</code>是對數組本身進行操作。之後，我查閱了許多資料才發現它實際上是對<em>拷貝</em>進行操作，然後我就以為事情就到此為止了。但最近我參與了一個對此事的討論，在經過一些小的實驗求證後，我發現事情並沒有我想的那麽簡單，事情並沒有結束。</p>

<p>讓我來告訴你們這是怎麼一回事。對於下面將會出現的例子，我們將用這個數組作為操作對象：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$array = array(1, 2, 3, 4, 5);</span></code></pre></td></tr></table></div></figure>


<p><a href="http://codepad.org/7DIeObk9," title="測試案例1">測試案例1</a>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>foreach ($array as $item) {
</span><span class='line'>  echo "$item\n";
</span><span class='line'>  $array[] = $item;
</span><span class='line'>}
</span><span class='line'>print_r($array);
</span><span class='line'>
</span><span class='line'>/* Output in loop:    1 2 3 4 5
</span><span class='line'>   $array after loop: 1 2 3 4 5 1 2 3 4 5 */</span></code></pre></td></tr></table></div></figure>


<p>很明顯這段代碼告訴我們，<code>foreach()</code> 並沒有操作源數組 - 否則循環將永遠執行下去，因此我們在循環的過程中不斷的往數組中添加元素。但只能肯定這一點 - 我們並沒有操作源數組:</p>

<p><a href="http://codepad.org/nirz6Ufh," title="測試案例2">測試案例2</a>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>foreach ($array as $key =&gt; $item) {
</span><span class='line'>  $array[$key + 1] = $item + 2;
</span><span class='line'>  echo "$item\n";
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>print_r($array);
</span><span class='line'>
</span><span class='line'>/* Output in loop:    1 2 3 4 5
</span><span class='line'>   $array after loop: 1 3 4 5 6 7 */</span></code></pre></td></tr></table></div></figure>


<p>該例子證明了我們最初的結論，在循環期間我們是操作的源數組拷貝，否則我們會在循環期間看到修改過後的值。<em>但是&#8230;</em></p>

<p>如果我們查看<a href="http://php.net/manual/en/control-structures.foreach.php," title="手冊">手冊</a>，我們會發現這樣的說法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>當 foreach 第一次執行的時候，內部指針會自動重置並指向到數組的第一個元素。</span></code></pre></td></tr></table></div></figure>


<p>好吧… 這樣看起來像是在說<code>foreach()</code>依賴於源數組的數組指針。但是我們不是剛剛證明我們並沒有操作源數組，不是嗎？好吧，可能不完全是。</p>

<p><a href="http://codepad.org/6n20ooMy," title="測試案例3">測試案例3</a>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Move the array pointer on one to make sure it doesn't affect the loop
</span><span class='line'>var_dump(each($array));
</span><span class='line'>
</span><span class='line'>foreach ($array as $item) {
</span><span class='line'>  echo "$item\n";
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var_dump(each($array));
</span><span class='line'>
</span><span class='line'>/* Output
</span><span class='line'>  array(4) {
</span><span class='line'>    [1]=&gt;
</span><span class='line'>    int(1)
</span><span class='line'>    ["value"]=&gt;
</span><span class='line'>    int(1)
</span><span class='line'>    [0]=&gt;
</span><span class='line'>    int(0)
</span><span class='line'>    ["key"]=&gt;
</span><span class='line'>    int(0)
</span><span class='line'>  }
</span><span class='line'>  1
</span><span class='line'>  2
</span><span class='line'>  3
</span><span class='line'>  4
</span><span class='line'>  5
</span><span class='line'>  bool(false)
</span><span class='line'>*/</span></code></pre></td></tr></table></div></figure>


<p>好吧，拋開我們並沒有操作源數組，但是動了源數組的指針這個事實不談 - 實際上在循環結束時，指針指向數組的末端說明了這一情況。除非這不可能是真的 - 如果是真的，<a href="http://codepad.org/7DIeObk9," title="測試案例1">測試案例1</a>將會進入死循環。</p>

<p>PHP文檔同樣也說：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>鑑於foreach依賴於內置數組指針，在循環期間修改它會導制不可預料的行為。</span></code></pre></td></tr></table></div></figure>


<p>好吧，讓我們來看看『不可預料的行為』是個什麼情況(文藝點的說法，任何我沒預料到的情況都是不可預料的行為)。</p>

<p><a href="http://codepad.org/JJp79xSd," title="測試案例4">測試案例4</a>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>foreach ($array as $key =&gt; $item) {
</span><span class='line'>  echo "$item\n";
</span><span class='line'>  each($array);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Output: 1 2 3 4 5 */</span></code></pre></td></tr></table></div></figure>


<p><a href="http://codepad.org/IfwJyTCL," title="測試案例5">測試案例5</a>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>foreach ($array as $key =&gt; $item) {
</span><span class='line'>  echo "$item\n";
</span><span class='line'>  reset($array);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Output: 1 2 3 4 5 */</span></code></pre></td></tr></table></div></figure>


<p>&#8230;瞧吧，沒有不可預料的行為，事實上和『源數組拷貝』理論更搭。</p>

<hr />

<p>請來個人幫我解釋一下這裏到底發生了什麼事情好嗎？我的C語言功底不怎麼好，所以不能通過看PHP源代碼來總結出一個合適的結論，如果有人能用英文給我解釋一下，我會非常感激的。</p>

<p>在我看來<code>foreach()</code>是對數組拷貝的操作，在對數組循環完成後，將源數組的數組指針指向末尾。</p>

<p>我的理解是對的嗎？就是這樣？
如果不是，那是怎麼回事？
有沒有情況是用函數( <code>each()</code>, <code>reset()</code> 這樣的函數？ )在循環裏來修正/調整數組指針的從而影響循環外的結果？</p>

<hr />

<p>注意：接下來的回答假設你對zvals在PHP裏怎麼工作已經有了一些基本的知識儲備，特別是你應該知道什麼是<code>refcount</code>，什麼是<code>is_ref</code>。</p>

<p><code>foreach()</code>適用於所有的可遍歷類型。比如說，數組，『純』對象( 可遍歷訪問的屬性 )和<code>可遍歷</code>對象( 或者是定義了<code>get_iterator</code>的對象 )。此回答將主要關注於數組，我會在文章末尾提到其它數據類型。</p>

<p>但是在進入正題前前，數組的一些背景知識和它們的循環在接下來的內容裏也同樣重要：</p>

<h1>數組循環的背景</h1>

<p>PHP裏的數組是有序的哈希表( 比如說，哈希桶是雙表連接<del>doubly linked list</del>的一部分 )，<code>foreach()</code>會按照這個順序遍歷數組。</p>

<p>PHP內置有兩套機制來遍歷數組：第一個便是內置數組指針。此指針是<code>哈希表</code>結構的一部分，並且只指向當前<code>哈希桶</code><del>HashTable Bucket</del>。修改操作是對內置數組指針無效的，比如，如果當前<code>哈希桶</code>被刪除，那麽內置數組指針將會更新，並指向下一個桶。</p>

<p>第二個機制便是<code>外置數組指針</code>，叫作<code>哈希位</code><del>HashPosition</del>。基本上此指針和內置數組指針一樣，不同的是它並不保存在<code>哈希表</code>裏。修改操作對外置循環機制是<strong>起作用</strong>的。如果你刪除了<code>哈希位</code>當前指向的<code>哈希桶</code>，那麽你就遺留了一個懸掛指針，導制分段錯誤。</p>

<p>此類外置數組指針只有在你十分確定以及肯定在循環期間沒有用戶代碼執行的情況下才能使用。用戶編寫的代碼可以通過多種渠道運行，比如錯誤處理，強制轉換或者zval銷燬。這就是為什麼在多數情況下，PHP使用內置數組指針而不用外置數組指針。如果不是PHP，那麽當用戶做些奇怪事情的時候會導制段錯誤<del>If it would not PHP could segfault when the user started doing weird things.</del>。</p>

<p>內置數組指針的問題便是它是<code>哈希表</code>的一部分。所以當你修改它時，你實際上是修改的<code>哈希表</code>和數組。同時，在PHP的語義中，數組是基於傳值的( 另一個是引用 )這就意味著在循環數組時，是對原數組的拷貝進行操作。</p>

<p>一個簡單嵌套循環的例子便說明拷貝是多麽的必要( 不是為了代碼簡潔考慮 ):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>foreach ($array as $a) {
</span><span class='line'>    foreach ($array as $b) {
</span><span class='line'>        // ...
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>這裏兩個循環是以一種奇怪的方式相互獨立的並且沒有共享它們的指針。</p>

<p>然後我們就可以開始<code>foreach()</code>了：</p>

<h1>用Foreach進行數組叠代</h1>

<p>現在你知道為什麼<code>foreach()</code>遍歷數組前拷貝了吧。但是這不僅僅是如此。PHP是否會進行拷貝操作基於以下幾個因素：</p>

<ul>
<li>如果叠代的數組是引用類型，拷貝就不起作用，取而代之的是執行<code>addref</code>：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ref =& $array; // $array has is_ref=1 now
</span><span class='line'>foreach ($array as $val) {
</span><span class='line'>    // ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>為什麼？因為數組的任何修改都應該通過引用影響到數組，包括內置數組指針。如果<code>foreach()</code>在這種情況下是對拷貝進行操作，那麽就違背了基本語義。</p>

<ul>
<li>如果數組的<code>refcount</code>為1，拷貝操作同樣不會執行。<code>refcount=1</code>的意思是指數組沒有在其它地方使用到，所以<code>foreach()</code>可以直接對其操作。如果<code>refcount</code>的值大於1，意思就是說，該數組和其它變量共享，並且為了避免修改，<code>foreach()</code>必須對其進行拷貝操作( 和之前的例子相反 )。</li>
<li>如果數組是以引用的方式被循環操作( <code>foreach( $array as &amp;$ref )</code> )，除了之前的拷貝/非拷貝操作行為之外 - 隨後將會創建一個指向數組的引用。</li>
</ul>


<p>這就是拷貝秘密的冰山一角。接下來便是循環到底是怎麼完成的，這有點奇怪。你所理解的『通常意義上的』循環( 同樣也適用於PHP中除了<code>foreach()</code>之外的所有情況 )基本上是這個樣子( 偽代碼 )：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reset();
</span><span class='line'>while (get_current_data(&data) == SUCCESS) {
</span><span class='line'>    code();
</span><span class='line'>    move_forward();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>foreach()</code>循環和其相比較起來，就有點小區別：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reset();
</span><span class='line'>while (get_current_data(&data) == SUCCESS) {
</span><span class='line'>    move_forward();
</span><span class='line'>    code();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>區別就是<code>move_foreard()</code>在第一次循環開始的時候就執行了，而不是在循環的末尾。所以假如當你的代碼在操作變量<code>$i</code>時，內置數組指針就已經指向<code>$i+1</code>了。</p>

<p><code>foreach()</code>的這種行為同樣也解釋了為什麼當當前數組元素被刪除時，內置數組指針總是指向<em>下一個</em>哈希桶，而不是上一個( 就像你期待的那樣 )。它就是這樣工作的，並且在<code>foreach()</code>裏表現的還不錯( 但是這種行為並不是在所有的情形下都表現上佳，在這個例子裏就會跳過某些數組元素 )。</p>

<h1>代碼的啟示</h1>

<p>第一條啟示便是我之前剛剛講到的行為 - <code>feach()</code>在很多情況下都是對數組拷貝進行循環操作的( 慢 )。但是別怕：實際上，我嘗試過拋開需求來進行循環操作，沒看到任何性能上的不同，我只能講這是心理因素在作怪( 這些循環顯示快了兩倍 )。看來人們並不是十分了解循環啊。:P</p>

<p>第二條啟示便是<em>通常</em>來說不應該有任何啟示。<code>foreach()</code>的行為對用戶來說是相當淺顯易懂的，就像它自己描述的那樣工作。你不用擔心它是怎麼拷貝數組啊，它的指針是怎麼指啊什麼的。</p>

<p>第三條啟示是 - 現在我們談到你遇到的問題了 - 有時你會<em>遇到</em>想破腦袋也搞不清楚的問題。特別是你在用<code>foreach()</code>修改數組時。</p>

<p>你可以在PHP的測試套件裏找到一大堆修改數組時遇到的極端情況。試試這個<a href="https://raw.github.com/php/php-src/master/tests/lang/foreachLoop.012.phpt," title="例子">例子</a>，比方講把數字從<code>012</code>改為<code>013</code>，你會看到<code>forach()</code>函數運行的各種情況( 不同的引用組合 )。</p>

<p>好吧，回到你的問題裏：</p>

<ul>
<li><p>測試案例1: 這裏 <code>$array()</code>的<code>refcount</code>在循環之前為1，所以它不會被拷貝，但是會有一個<code>addref</code>。當你在循環內部對<code>$array[]</code>操作時，zval將會被分離，所以說，你在循環裏往裏添加元素的那個數組和在循環過程中的數組是不相關的。</p></li>
<li><p>測試案例2：和1同理。</p></li>
<li><p>測試案例3：是的，還是一個道理。在<code>foreach()</code>循環裏，<code>refcount</code>為1，你僅能得到一個<code>addref</code>和修改<code>$array()</code>內置指針的能力。所以說在循環結束後，指針是NULL( 意思是說循環結束 )。<code>each()</code>返回當前指針，就是<code>false</code>。</p></li>
<li><p>測試案例4和5：<code>each()</code>和<code>reset()</code>都是引用類型函數。當將<code>array()</code>作為參數傳遞給這兩個函數時，它的<code>refcount</code>為2，所以說它被分離了。再一次，<code>foreach()</code>是操作分離出來的數組。</p></li>
</ul>


<p>但是你舉的例子很爛。只有當你在循環裏用到<code>current()</code>函數你才能直觀的看到指針行為。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>foreach ($array as $val) {
</span><span class='line'>    var_dump(current($array));
</span><span class='line'>}
</span><span class='line'>/* Output: 2 2 2 2 2 */</span></code></pre></td></tr></table></div></figure>


<p>這裏你應該知道<code>current()</code>是一個引用類型函數，即使它並沒有修改數組。它和諸如<code>next()</code>之類的引用類型函數一起使用才有效果。( <code>current</code>實際上是一個<code>prefer-ref</code>函數，傳值或是引用都可以。 )『引用』意思是指數組被分離，<code>$array</code>和<code>foreach()</code>裏的<code>$array</code>是兩碼事。上面例子裏結果是<code>2</code>而不是<code>1</code>和之前講的是一個道理：<code>foreach()</code>在用戶代碼執行<em>之前</em>就已經移動了數組指針，而不是之後。所以即使是代碼在第一個元素，<code>foreach()</code>已經移動指針到下一個元素了。</p>

<p>現在讓我們來小改一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ref = &$array;
</span><span class='line'>foreach ($array as $val) {
</span><span class='line'>    var_dump(current($array));
</span><span class='line'>}
</span><span class='line'>/* Output: 2 3 4 5 false */</span></code></pre></td></tr></table></div></figure>


<p>這個例子是<code>is_ref</code>為1的情況，所以數組沒有被拷貝( 和之前一樣 )。但現在的情況就是數組被傳遞給引用類型的函數<code>current()</code>時，它不再分離了。所以目前 <code>current()</code>和<code>foreach()</code>都是操作的同一個數組。在<code>foreach()</code>操作數組的過程中，你仍然會看到大小差一<del>off-by-one</del>的情況。</p>

<p>當以引用的方式來循環時，也會得到同樣的結果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>foreach ($array as &$val) {
</span><span class='line'>    var_dump(current($array));
</span><span class='line'>}
</span><span class='line'>/* Output: 2 3 4 5 false */</span></code></pre></td></tr></table></div></figure>


<p>這裏要提一下的是當以引用的方法循環時，<code>foreach()</code>將會設<code>$array</code>的<code>is_ref</code>為1，基本上你會得到和之前同樣的結果。</p>

<p>另外一個小改動：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$foo = $array;
</span><span class='line'>foreach ($array as $val) {
</span><span class='line'>    var_dump(current($array));
</span><span class='line'>}
</span><span class='line'>/* Output: 1 1 1 1 1 */</span></code></pre></td></tr></table></div></figure>


<p>這裏在循環開始時，<code>$array</code>的<code>refcount</code>是2，這一次我們實際上執行了拷貝操作。因此<code>$array</code>和<code>foreach()</code>裏的<code>$array()</code>是完全不同的。這就是為什麼在循環開始前你會得到內置指針指向的位置( 在這個例子裏，它是指向在第一個元素 )。</p>

<h1>對象的循環</h1>

<p>當一個對象循環時，要滿足兩種情況：</p>

<ul>
<li>對象不是<code>可遍歷的</code>( 或者這樣講：沒有定義內置的<code>get_iterator</code>句柄 )。在這種情況下的循環和數組非常相似。適用於同樣的拷貝語義。唯一不同的情況便是<code>foreach()</code>將會運行一些額外的代碼用來跳過不在當前範圍內的屬性。隨便列幾個真實的情況：

<ul>
<li><p>對於聲明的屬性，PHP會優化屬性哈希表。如果你循環完整個對象，那麽它會自動重新構建哈希表( 增加內存使用 )。[ 你不應被這麻煩到，小事而已 ]</p></li>
<li><p>每次叠代都會取屬性的哈希表。比如PHP將會重復重復再重復的調用<code>get_properties</code>句柄。對『正常』屬性來講，這會造成些細小差別，但是如果這些屬性是在句柄裏動態生成的( 這就是類內部經常幹的事 )，那就意味著屬性哈希表每次都會重建。</p></li>
</ul>
</li>
<li>對象是<code>可遍歷的</code>。在這種情況下，千言萬語匯成一句話 - 那就是之前我們已經說了的 - <strong>不可能</strong>。這裏PHP不會做任何拷貝操作並且也不會『在循環開始之前就移動指針』。我認為<code>可遍歷</code>的循環操作是更容易預測並且無需多說。:)</li>
</ul>


<h1>在循環過程中替代叠代元素</h1>

<p>另一個奇怪的地方我之前沒有提到的便是PHP允許你在叠代的過程中替換叠代元素。所以講，你可以在循環一個數組時，在叠代期間用另一個數組替換掉它。或者是用對象替換。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$arr = [1, 2, 3, 4, 5];
</span><span class='line'>$obj = (object) [6, 7, 8, 9, 10];
</span><span class='line'>
</span><span class='line'>$ref =& $arr;
</span><span class='line'>foreach ($ref as $val) {
</span><span class='line'>    echo "$val\n";
</span><span class='line'>    if ($val == 3) {
</span><span class='line'>        $ref = $obj;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>/* Output: 1 2 3 6 7 8 9 10 */</span></code></pre></td></tr></table></div></figure>


<p>就像你從這個例子中理解的一樣，在代碼開頭聲明的對象替換完成後循環才能繼續直到叠代完成。</p>

<h1>在循環期間改變內置數組指針</h1>

<p>另一個之前我沒有說到的<code>foreach()</code>行為細節( 它真的會產生一些莫名奇妙的行為 )便是在循環期間改變內置數組指針發生的奇怪的事情。</p>

<p>它或許不像你期待的那樣工作：當在循環體( 引用情形 )裏調用<code>next()</code>或是<code>prev()</code>時，你會發現內置數組指針移動了，但是對循環的行為沒有起到作用。究其原因就是<code>foreach()</code>會在每次叠代後都備份當前地址和hash當前元素到<code>哈希指針</code>。在進行下一個叠代時，<code>foreach()</code>便會檢查內置指針指向的地址是否被修改並嘗試回復到之前元素的狀態( 基於哈希表 )。</p>

<p>讓我們瞧瞧『嘗試』是怎麼『嘗』的。首先，這裏有一個例子，展示了內置指針<em>沒有</em>改變<code>foreach()</code>行為時的變化：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$array = [1, 2, 3, 4, 5];
</span><span class='line'>$ref =& $array;
</span><span class='line'>foreach ($array as $value) {
</span><span class='line'>    var_dump($value);
</span><span class='line'>    reset($array);
</span><span class='line'>}
</span><span class='line'>// output: 1, 2, 3, 4, 5</span></code></pre></td></tr></table></div></figure>


<p>接下來讓我們移去<code>foreach()</code>在第一次叠代時指針所指的元素( 鍵1 )：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$array = [1, 2, 3, 4, 5];
</span><span class='line'>$ref =& $array;
</span><span class='line'>foreach ($array as $value) {
</span><span class='line'>    var_dump($value);
</span><span class='line'>    unset($array[1]);
</span><span class='line'>    reset($array);
</span><span class='line'>}
</span><span class='line'>// output: 1, 1, 3, 4, 5</span></code></pre></td></tr></table></div></figure>


<p>你看到之後發生了什麼事了( 兩個1 )，因為備份了散列碼的元素已經被刪除了。</p>

<p>記住哈希就是把東西弄亂<del>Hash的中文意思裏有弄亂的意思</del>，比如說衝突。所以吧，讓我們看看下面這個代碼片段：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$array = ['EzEz' =&gt; 1, 'EzFY' =&gt; 2, 'FYEz' =&gt; 3];
</span><span class='line'>$ref =& $array;
</span><span class='line'>foreach ($array as $value) {
</span><span class='line'>    unset($array['EzFY']);
</span><span class='line'>    $array['FYFZ'] = 4;
</span><span class='line'>    reset($array);
</span><span class='line'>    var_dump($value);
</span><span class='line'>}
</span><span class='line'>// output: 1 1 3 4</span></code></pre></td></tr></table></div></figure>


<p>結果可以預計。我們移去了鍵<code>EzFY</code>( 當前<code>foreach()</code>所在的位置 )，然後調用<code>reset()</code>。除此之外，我們又新設置了個鍵，<code>4</code>就自然而然的加到了循環的最後了。</p>

<p>但是這點有個搞怪了。如果我們把<code>FYFZ</code>換成<code>FYFY</code>又會怎樣呢？來看看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$array = ['EzEz' =&gt; 1, 'EzFY' =&gt; 2, 'FYEz' =&gt; 3];
</span><span class='line'>$ref =& $array;
</span><span class='line'>foreach ($array as $value) {
</span><span class='line'>    unset($array['EzFY']);
</span><span class='line'>    $array['FYFY'] = 4;
</span><span class='line'>    reset($array);
</span><span class='line'>    var_dump($value);
</span><span class='line'>}
</span><span class='line'>// output: 1 4</span></code></pre></td></tr></table></div></figure>


<p>現在循環直接訪問到新加元素，無視餘下的數組元素。原因還是鍵<code>FYFY</code>和鍵<code>EzFY</code>衝突了( 實際上該數組中的所有鍵都衝突了 )。此外<code>FYFY</code>的哈希桶和<code>EzFY</code>的哈希桶用的是同一個內存地址，所以<code>EzFY</code>就被拋棄掉了。所以對PHP來講，還是同一個位置，同一個哈希表。只是位置被『重置』了，因此就直接跳到了數組末尾。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Magento產品評論中出現的時區問題]]></title>
    <link href="http://billsion.github.io/blog/2013/06/18/magento-review-time-zone-configuration/"/>
    <updated>2013-06-18T11:15:00+08:00</updated>
    <id>http://billsion.github.io/blog/2013/06/18/magento-review-time-zone-configuration</id>
    <content type="html"><![CDATA[<p>昨天下午遇到了個頭疼的問題，客戶對產品評論的時間總是晚於客服回復的時間，這個根本說不通，按照常理來講，只能先評論，客服才能對評論進行回復。知道問題所在，於是開始DEBUG。</p>

<ul>
<li><p>首先檢查對應的模塊有沒有被重寫，查看<code>config.xml</code>配置文件裏的<code>&lt;rewrite&gt;</code>項，沒有重寫，證明Model是幹凈的。同時再看Controller部分有沒有問題，也沒有，說明根本沒有重寫這個模塊。</p></li>
<li><p>再檢查是否有顯示的設置了<code>created_at</code>或是<code>updated_at</code>時間，在代碼裏。結果也是沒有。</p></li>
</ul>


<p>這就奇怪了，於是接下來檢查PHP和MYSQL的時區設置。</p>

<ul>
<li><p>寫個腳本查看phpinfo()或是<code>php.ini</code>，時區是 <code>Asia/Shanghai</code>，沒問題，是對的。</p></li>
<li><p>在MySQL裏運行 <code>show variables like '%time_zone%'</code>; 發現 <code>default_time_zone</code>是用的<code>SYSTEM</code>，於是在 <code>/etc/my.cnf</code> 裏加一句 <code>default_time_zone='+8:00'</code>，重啟MySQL。搞掟時區問題。</p></li>
</ul>


<p>現在時區顯示是對了，但是時間還是不對，於是查看對應表<code>review</code>的schema發現，<code>created_at</code>這裏填寫的是 <code>CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</code>，這就是原因，這就是為什麼回復評論的時間在評論創建的時間之前。可以給Magento提交BUG了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Mac OS X里面升级原生PHP]]></title>
    <link href="http://billsion.github.io/blog/2013/06/07/upgrade-php-version-in-mac-os-x/"/>
    <updated>2013-06-07T10:18:00+08:00</updated>
    <id>http://billsion.github.io/blog/2013/06/07/upgrade-php-version-in-mac-os-x</id>
    <content type="html"><![CDATA[<p>目前机器上的PHP版本是5.3.15，低了，想升到5.4，于是百度搜了下，出来的都是三条语句升级:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew tap homebrew/dupes
</span><span class='line'>brew tap josegonzalez/homebrew-php
</span><span class='line'>brew install hp54</span></code></pre></td></tr></table></div></figure>


<p>实际上这样并不能安装成功，因为目标文件已经不存在了。于是求助Google，在StackOverflow上找到了答案。<a href="http://php-osx.liip.ch/">这里</a></p>

<p>一句话就OK:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -s http://php-osx.liip.ch/install.sh | bash -s 5.4</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Magento里面创建一个自定义路由]]></title>
    <link href="http://billsion.github.io/blog/2013/06/03/create-a-custom-router-in-magento/"/>
    <updated>2013-06-03T11:37:00+08:00</updated>
    <id>http://billsion.github.io/blog/2013/06/03/create-a-custom-router-in-magento</id>
    <content type="html"><![CDATA[<p>本文译自<a href="http://inchoo.net/ecommerce/magento/custom-router-in-magento/">Inchoo</a></p>

<p>当我们需要把业务逻辑从Magento默认的路由中区别开来，不受Magento默认路由的影响，创建一个自定义的路由功能就显得很方便了。</p>

<p>那为什么我们不能为不同的逻辑创建不同的路由呢？</p>

<p>让我来简单解释一下：在我的一个客户的项目中，我整合过一个 <code>OneStepCheckout</code> 的扩展，这个扩展重写了Magento核心的路由功能。我需要重写这些路由甚至要根据URL里的参数把它们分派到两个不同的控制器。基于这要的要求，我发现最节省时间的方法便是创建一个新路由，由它来根据不同的参数重定向到不同的控制器。</p>

<p>我们来开始定义:</p>

<p><strong>../app/code/local/Mynamespace/Myextension/etc/config.xml</strong>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;default&gt;
</span><span class='line'>   &lt;web&gt;
</span><span class='line'>     &lt;routers&gt;
</span><span class='line'>        &lt;myextension_myrouter&gt;
</span><span class='line'>            &lt;area&gt;frontend&lt;/area&gt;
</span><span class='line'>            &lt;class&gt;Mynamespace_Myextension_Controller_Router&lt;/class&gt;
</span><span class='line'>        &lt;/myextension_myrouter&gt;
</span><span class='line'>    &lt;/routers&gt;
</span><span class='line'>   &lt;/web&gt;
</span><span class='line'>  &lt;/default&gt;
</span><span class='line'>&lt;/stores&gt;</span></code></pre></td></tr></table></div></figure>


<p>在 <strong>/app/code/local/Mynamespace/Myextension</strong>里创建一个新文件夹，名为 <strong>Controller</strong>。也创建一个PHP类: <strong>Mynamespace_Myextension_Controller_Router.php</strong>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?php
</span><span class='line'>//Mynamespace_Myextension_Controller_Router.php
</span><span class='line'>/**
</span><span class='line'> * @author Darko Goleš &lt;darko.goles@inchoo.net&gt;
</span><span class='line'> * Router for deciding to go on party checkout or regular onestepcheckout
</span><span class='line'> */
</span><span class='line'>class Mynemaspace_Myextension_Controller_Router extends Mage_Core_Controller_Varien_Router_Standard {
</span><span class='line'>}
</span><span class='line'>?&gt;</span></code></pre></td></tr></table></div></figure>


<p>为了避免重复发明轮子，我们可以直接从已有的源代码<strong>Mage_Core_Controller_Varien_Router_Standard.php</strong>中复制出内容并粘贴到我们的文件里，同时作些修改:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>   * Match the request
</span><span class='line'>   *
</span><span class='line'>   * @param Zend_Controller_Request_Http $request
</span><span class='line'>   * @return boolean
</span><span class='line'>   */
</span><span class='line'>  public function match(Zend_Controller_Request_Http $request)
</span><span class='line'>  {
</span><span class='line'>      //checking before even try to find out that current module
</span><span class='line'>      //should use this router
</span><span class='line'>      if (!$this-&gt;_beforeModuleMatch()) {
</span><span class='line'>          return false;
</span><span class='line'>      }
</span><span class='line'>      $this-&gt;fetchDefault();
</span><span class='line'>      $front = $this-&gt;getFront();
</span><span class='line'>      $path = trim($request-&gt;getPathInfo(), '/');
</span><span class='line'>      if ($path) {
</span><span class='line'>          $p = explode('/', $path);
</span><span class='line'>      } else {
</span><span class='line'>          $p = explode('/', $this-&gt;_getDefaultPath());
</span><span class='line'>      }
</span><span class='line'>      // get module name
</span><span class='line'>      if ($request-&gt;getModuleName()) {
</span><span class='line'>          $module = $request-&gt;getModuleName();
</span><span class='line'>      } else {
</span><span class='line'>          if (!empty($p[0])) {
</span><span class='line'>              $module = $p[0];
</span><span class='line'>          } else {
</span><span class='line'>              $module = $this-&gt;getFront()-&gt;getDefault('module');
</span><span class='line'>              $request-&gt;setAlias(Mage_Core_Model_Url_Rewrite::REWRITE_REQUEST_PATH_ALIAS, '');
</span><span class='line'>          }
</span><span class='line'>      }
</span><span class='line'>      if (!$module) {
</span><span class='line'>          if (Mage::app()-&gt;getStore()-&gt;isAdmin()) {
</span><span class='line'>              $module = 'admin';
</span><span class='line'>          } else {
</span><span class='line'>              return false;
</span><span class='line'>          }
</span><span class='line'>      }
</span><span class='line'>      /**
</span><span class='line'>       * Searching router args by module name from route using it as key
</span><span class='line'>       */
</span><span class='line'>      $modules = $this-&gt;getModuleByFrontName($module);
</span><span class='line'>      if ($modules === false) {
</span><span class='line'>          return false;
</span><span class='line'>      }
</span><span class='line'>      //checkings after we foundout that this router should be used for current module
</span><span class='line'>      if (!$this-&gt;_afterModuleMatch()) {
</span><span class='line'>          return false;
</span><span class='line'>      }
</span><span class='line'>      /**
</span><span class='line'>       * Going through modules to find appropriate controller
</span><span class='line'>       */
</span><span class='line'>      $found = false;
</span><span class='line'>      foreach ($modules as $realModule) {
</span><span class='line'>          $request-&gt;setRouteName($this-&gt;getRouteByFrontName($module));
</span><span class='line'>          // get controller name
</span><span class='line'>          if ($request-&gt;getControllerName()) {
</span><span class='line'>              $controller = $request-&gt;getControllerName();
</span><span class='line'>          } else {
</span><span class='line'>              if (!empty($p[1])) {
</span><span class='line'>                  $controller = $p[1];
</span><span class='line'>              } else {
</span><span class='line'>                  $controller = $front-&gt;getDefault('controller');
</span><span class='line'>                  $request-&gt;setAlias(
</span><span class='line'>                      Mage_Core_Model_Url_Rewrite::REWRITE_REQUEST_PATH_ALIAS,
</span><span class='line'>                      ltrim($request-&gt;getOriginalPathInfo(), '/')
</span><span class='line'>                  );
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>          // get action name
</span><span class='line'>          if (empty($action)) {
</span><span class='line'>              if ($request-&gt;getActionName()) {
</span><span class='line'>                  $action = $request-&gt;getActionName();
</span><span class='line'>              } else {
</span><span class='line'>                  $action = !empty($p[2]) ? $p[2] : $front-&gt;getDefault('action');
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>          //checking if this place should be secure
</span><span class='line'>          $this-&gt;_checkShouldBeSecure($request, '/'.$module.'/'.$controller.'/'.$action);
</span><span class='line'>          $controllerClassName = $this-&gt;_validateControllerClassName($realModule, $controller);
</span><span class='line'>          if (!$controllerClassName) {
</span><span class='line'>              continue;
</span><span class='line'>          }
</span><span class='line'>          // instantiate controller class
</span><span class='line'>          $controllerInstance = Mage::getControllerInstance($controllerClassName, $request, $front-&gt;getResponse());
</span><span class='line'>          if (!$controllerInstance-&gt;hasAction($action)) {
</span><span class='line'>              continue;
</span><span class='line'>          }
</span><span class='line'>          $found = true;
</span><span class='line'>          break;
</span><span class='line'>      }
</span><span class='line'>      /**
</span><span class='line'>       * if we did not found any siutibul
</span><span class='line'>       */
</span><span class='line'>      if (!$found) {
</span><span class='line'>          if ($this-&gt;_noRouteShouldBeApplied()) {
</span><span class='line'>              $controller = 'index';
</span><span class='line'>              $action = 'noroute';
</span><span class='line'>              $controllerClassName = $this-&gt;_validateControllerClassName($realModule, $controller);
</span><span class='line'>              if (!$controllerClassName) {
</span><span class='line'>                  return false;
</span><span class='line'>              }
</span><span class='line'>              // instantiate controller class
</span><span class='line'>              $controllerInstance = Mage::getControllerInstance($controllerClassName, $request,
</span><span class='line'>                  $front-&gt;getResponse());
</span><span class='line'>              if (!$controllerInstance-&gt;hasAction($action)) {
</span><span class='line'>                  return false;
</span><span class='line'>              }
</span><span class='line'>          } else {
</span><span class='line'>              return false;
</span><span class='line'>          }
</span><span class='line'>      }
</span><span class='line'>      // set values only after all the checks are done
</span><span class='line'>      $request-&gt;setModuleName($module);
</span><span class='line'>      $request-&gt;setControllerName($controller);
</span><span class='line'>      $request-&gt;setActionName($action);
</span><span class='line'>      $request-&gt;setControllerModule($realModule);
</span><span class='line'>      // set parameters from pathinfo
</span><span class='line'>      for ($i = 3, $l = sizeof($p); $i &lt; $l; $i += 2) {
</span><span class='line'>          $request-&gt;setParam($p[$i], isset($p[$i+1]) ? urldecode($p[$i+1]) : '');
</span><span class='line'>      }
</span><span class='line'>      // dispatch action
</span><span class='line'>      $request-&gt;setDispatched(true);
</span><span class='line'>      $controllerInstance-&gt;dispatch($action);
</span><span class='line'>      return true;
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>打个比方，现在我想要根据&#8221;Party&#8221;是否定义来重定向路由到不同的控制器。&#8221;Party&#8221;是前缀，那么正常的控制器会是这样:
<strong>Mynamespace/MyExtension/controllers/Somecontrollername.php</strong>
加了&#8221;Party&#8221;之后的控制器会是这样:
<strong>Mynamespace/MyExtension/controllers/</strong><em>Party</em><strong>/Somecontrollername.php</strong></p>

<p>为了实现这个，让我们在上面的代码中57~62行加入下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//...
</span><span class='line'>        $party_prefix = '';
</span><span class='line'>        if ($this-&gt;isPartyOrder($request)) {
</span><span class='line'>            foreach ($modules as $key =&gt; $realModule) {
</span><span class='line'>                $modules[$key].='_Party';
</span><span class='line'>            }
</span><span class='line'>            $party_prefix = '_party';
</span><span class='line'>        }
</span><span class='line'>//...</span></code></pre></td></tr></table></div></figure>


<p>当然，我们的<code>isParty</code>方法会是这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>..
</span><span class='line'>    /**
</span><span class='line'>     * Determine if order is "Party order"
</span><span class='line'>     * @param Mage_Core_Controller_Request_Http $request
</span><span class='line'>     * @return boolean
</span><span class='line'>     */
</span><span class='line'>    private function isPartyOrder($request) {
</span><span class='line'>        if (isset($_SESSION['is_party_checkout']) && $_SESSION['is_party_checkout']) {
</span><span class='line'>            return true;
</span><span class='line'>        }
</span><span class='line'>        $pathInfo = $request-&gt;getPathInfo();
</span><span class='line'>        if (stristr($pathInfo, 'onestepcheckout/index/index')) {
</span><span class='line'>            $params = Mage::app()-&gt;getRequest()-&gt;getParams();
</span><span class='line'>            if (isset($params['id'])) {
</span><span class='line'>                return true;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return false;
</span><span class='line'>    }
</span><span class='line'>..
</span></code></pre></td></tr></table></div></figure>


<p>这里这段代码检查了<code>Party</code>是按照Session排序还是按照GET里的顺序排序。</p>

<p>按下来，我们将把下面的代码改一下，以便适应我们layout.xml里面用到的路由名字。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>       * Going through modules to find appropriate controller
</span><span class='line'>       */
</span><span class='line'>      $found = false;
</span><span class='line'>      foreach ($modules as $realModule) {
</span><span class='line'>          $request-&gt;setRouteName($this-&gt;getRouteByFrontName($module));</span></code></pre></td></tr></table></div></figure>


<p>…我们只改一行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//...
</span><span class='line'>        /**
</span><span class='line'>         * Going through modules to find appropriate controller
</span><span class='line'>         */
</span><span class='line'>        $found = false;
</span><span class='line'>        foreach ($modules as $realModule) {
</span><span class='line'>            $request-&gt;setRouteName('ourextension_' . $this-&gt;getRouteByFrontName($module) . $party_prefix);
</span><span class='line'>        ...
</span><span class='line'>//...</span></code></pre></td></tr></table></div></figure>


<p>现在我们可以在layout.xml文件里定义我们的layaout处理带&#8221;Party&#8221;的控制器和带规控制器:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0"?&gt;
</span><span class='line'>&lt;layout version="0.1.0"&gt;
</span><span class='line'>    &lt;ourmodule_controllername_actionname&gt;
</span><span class='line'>      &lt;block ....... some layout updates ... etc
</span><span class='line'>    &lt;/ourmodule_controllername_actionname&gt;
</span><span class='line'>   &lt;ourmodule_party_controllername_actionname&gt;
</span><span class='line'>      &lt;block ....... some different layout updates ... etc
</span><span class='line'>   &lt;/ourmodule_party_controllername_actionname&gt;
</span><span class='line'>&lt;/layout&gt;</span></code></pre></td></tr></table></div></figure>


<p>这样的话，就可以完完全全将两种情况分开来处理了。</p>

<p>这里只是个展示怎么创建和修改自定义路由的小例子，你可以根据实际情况将路由写成自己需要的那样。</p>

<p>让我们再来看看我写的模块里<code>config.xml</code>里面，路由是怎么和<code>Onestepcheckout</code>交互的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;frontend&gt;
</span><span class='line'>        &lt;routers&gt;
</span><span class='line'>            &lt;onestepcheckout&gt;
</span><span class='line'>                &lt;use&gt;myextension_myrouter&lt;/use&gt;
</span><span class='line'>                &lt;args&gt;
</span><span class='line'>                    &lt;modules&gt;
</span><span class='line'>                        &lt;Mynamespace_Mymodule before="Idev_OneStepCheckout"&gt;Mynamespace_Mymodule_Onestepcheckout&lt;/Mynamespace_Mymodule&gt;
</span><span class='line'>                    &lt;/modules&gt;
</span><span class='line'>                &lt;/args&gt;
</span><span class='line'>            &lt;/onestepcheckout&gt;
</span><span class='line'>        &lt;/routers&gt;</span></code></pre></td></tr></table></div></figure>


<p>现在的问题便是:
<code>Onestepcheckout</code>模块重写了Magento的核心路由，所以当用户访问 <code>checkout/onepage</code> 的地址时，他们将会被定向到<code>Onepagecheckout</code>的URL。</p>

<p>当我像上面这样创建了自定义路由之后，用户将仍然访问<code>Onepagecheckout</code>的路由，除非有&#8221;Party&#8221;。</p>

<p>因为这两次请求（Party或是常规）都是同一文件，我们只是在我们的路由设置里设置了不同的路由名字，所以我们可以在layout里面用到不同的处理。</p>

<p>I know this seems a little bit messy for one reading, but I hope somebody will find this post useful for own projects and extension integrations and customizations. Cheers.</p>

<p>我知道把不同的请求放入一个文件里看起来有些混乱，但我希望此文起到一个抛砖引玉的作用，有人能够看到此文中有用的地方并用到自己的项目里。</p>

<p>谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Magento中序例化Block]]></title>
    <link href="http://billsion.github.io/blog/2013/06/03/understanding-the-grid-serializer-block/"/>
    <updated>2013-06-03T10:49:00+08:00</updated>
    <id>http://billsion.github.io/blog/2013/06/03/understanding-the-grid-serializer-block</id>
    <content type="html"><![CDATA[<p>本文译自: <a href="http://magebase.com/magento-tutorials/understanding-the-grid-serializer-block/">magebase.com</a></p>

<h3>多选框的不足之处</h3>

<p>在电商平台上，很多情况下都存在一对多的关系。举几个熟悉的例子，像追加销售，交叉销售，相关产品这些情况。一个产品可能会对应不只一个促销。我们用追加销售来打比方，一个产品可以对应多个作为追加销售存在的产品。 通常情况下是在表单或是管理页面中使用多选框来管理此类数据或是关系，但是这样有几个不足：</p>

<ol>
<li>只能显示产品的一个属性。在这个例子中，我们只能显示产品名字在多选框里，但是要显示如SKU或是价格之类的属性的话，就不是那么容易就能办到的。</li>
<li>用户只能选择多个产品，仅仅是选中，对额外数据无能为力。在这个例子中，表单只能提交选中的产品，但对各个选中产品的排列位置无能为力。</li>
<li>数据量的增多会导制选项增多，多选框会变得庞大，难以管理。</li>
<li>不能排序或是过滤，用户在找特定选项的时候会很困难。</li>
</ol>


<h3>作为表单元素的表格组件</h3>

<p>为了克服多选框的局限性，我们需要有一个高级的表单元素，它应该包含如下功能：</p>

<ol>
<li>可以正选/反选多个实体。</li>
<li>可以显示实体更多的信息。</li>
<li>可以保存用户输入的额外数据。</li>
<li>当数据量大的情况下，支持分页。</li>
<li>支持复杂排序和过滤。</li>
<li>格式应该统一，这样一来可以用在不同的实体或是不同的数据。</li>
</ol>


<p>幸运的是，Magento自带一些非常有意思的管理组件，特别是涉汲到后台插件的开发。这些组件太强大了，开发人员只需要写很少的代码或是&#8217;不&#8217;写模板便能创建出很直观的页面了。</p>

<p>其中一个组件便是“表格”。 它内置了分页，排序和过滤。表格组件广泛用于后台管理界面，比如用来显示产品，订单，发票，注册用户等。但是我最中意的使 用便是作为表单元素。Magento提供了一个非常完美的解决方案用来克服之前说到的那些个不足，什么一对多啊之类的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$this-&gt;addColumn('in_products', array(
</span><span class='line'>    'header_css_class' =&gt; 'a-center',
</span><span class='line'>    'type'            =&gt; 'checkbox',
</span><span class='line'>    'name'            =&gt; 'in_products',
</span><span class='line'>    'values'          =&gt; $this-&gt;_getSelectedProducts(),
</span><span class='line'>    'align'           =&gt; 'center',
</span><span class='line'>    'index'           =&gt; 'entity_id'
</span><span class='line'> ));
</span></code></pre></td></tr></table></div></figure>


<p>当用表格作为表单元素来替代多选框时，正常情况下，第一列的类型应该设为&#8217;checkbox&#8217;。这样一来，表格的每一行的第一列都会显示为checkbox。用户也就可以更好的选中他们想选择的数据。用此种方法进行多选比使用老式的多选框有效率多了。</p>

<h3>AJAX之间数据的可持久性</h3>

<p>第一眼看，此种机制堪称完美。但，表格同样也有分页，排序和过滤。每次执行其中的操作时，表格就通过AJAX调用进行重新加载，每次表格重新加载，之前选中的实体便会丢失。打个比方，我们正在选择追加销售商品，我们通过表格第一列的checkbo选中三个产品。现在，我们点击&#8217;下一页&#8217;链接来加载下一页的产品，或者同时在这个页面也选3个产品。然后，我们点击&#8217;上一页&#8217;链接回到之前的页。我们会发现之前选中的3个产品没有被选中，执行排序或是过滤也会导制同样的问题。所以讲，当表格组件搞定了老式多选框的不足后，诸如分页，过滤或是排序这类的操作会导制数据持久性的新问题。</p>

<h3>序列化Block是如何处理数据的可持久性问题</h3>

<p>Magento提供了另外一种Block叫作&#8217;Serializer Block&#8217;(序列化Block)，用它来处理选中数据的持久性问题。这种Block通常情况下会添加在表格Block的后面。该Block包含一个隐藏域和一个序列化过的JS对象。经过序列化的JS对象使用表格JS对象来得到选中的行。然后再序列化，像这样: key1=value1&amp;key2=value2&amp;…，再把经过序列化后的值赋给隐藏域。因为这个Block并没有嵌套在表格Block里面，所以即使是通过AJAX方式重新加载了表格Block，但是值被保存了下来。这个经过序列化过后的值，作为表单的一部分提交，在PHP端则通过 <code>parse_str()</code>函数来反序列化。</p>

<p>不管怎么说，表单元素不光是用来存储用户输入的数据，同时也要显示之前已经保存过的数据。打个比方，当我们在文本框里填写了一些文本，那么我们填写的内容就会显示在里面。当我们从下拉框里面选中了任何一项，那么它就会默认显示我们选中的选项。同理，在此表格组件中也应该能显示选中的行。换句话讲，选中的行应该在第一列的checkbox里标记为checked。</p>

<p>因此，序列化的JS对象在观察者事件观察表格的JS对象行为。所以当一个表格Block重载的时候，序列化的JS对象自动选中我们之前已经选中的行。</p>

<p>那么，基于以上这些理论，我们可以把注意力放在怎么用这些知识去打造一个自定义的后台表格系统。</p>

<h3>使用序列化表格Block</h3>

<p>Magento提供了一个内置的库用来创建自定义表格和序列化Block。我们用追加销售表格来分析理解一下它是怎么工作的。</p>

<p>在产品的编辑页面，左侧有一标签-追加销售。标签内容是通过AJAX加载。点击标签访问这个Action: Mage_Adminhtml_Catalog_ProductController::upsellAction()。</p>

<p>那么该行为的布局就定义在下面的布局文件里 <code>app/design/adminhtml/default/default/catalog.xml</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;adminhtml_catalog_product_upsell&gt;
</span><span class='line'>    &lt;block type="core/text_list" name="root"&gt;
</span><span class='line'>        &lt;block type="adminhtml/catalog_product_edit_tab_upsell" name="catalog.product.edit.tab.upsell"/&gt;
</span><span class='line'>        &lt;block type="adminhtml/widget_grid_serializer" name="upsell_grid_serializer"&gt;
</span><span class='line'>            &lt;reference name="upsell_grid_serializer"&gt;
</span><span class='line'>                &lt;action method="initSerializerBlock"&gt;
</span><span class='line'>                    &lt;grid_block_name&gt;catalog.product.edit.tab.upsell&lt;/grid_block_name&gt;
</span><span class='line'>                    &lt;data_callback&gt;getSelectedUpsellProducts&lt;/data_callback&gt;
</span><span class='line'>                    &lt;hidden_input_name&gt;links[upsell]&lt;/hidden_input_name&gt;
</span><span class='line'>                    &lt;reload_param_name&gt;products_upsell&lt;/reload_param_name&gt;
</span><span class='line'>                &lt;/action&gt;
</span><span class='line'>                &lt;action method="addColumnInputName"&gt;
</span><span class='line'>                    &lt;input_name&gt;position&lt;/input_name&gt;
</span><span class='line'>                &lt;/action&gt;
</span><span class='line'>            &lt;/reference&gt;
</span><span class='line'>        &lt;/block&gt;
</span><span class='line'>    &lt;/block&gt;
</span><span class='line'>&lt;/adminhtml_catalog_product_upsell&gt;</span></code></pre></td></tr></table></div></figure>


<p>这里，Block根节点是 core/text_list 类型。所以所有的子节点全都都按照顺序渲染。请看<a href="http://magebase.com/magento-tutorials/demystifying-magentos-layout-xml-part-1/">Demystifying Magento’s Layout XML Part 1</a>。</p>

<p>第一个子Block <code>catalog.product.edit.tab.upsell</code> 是 <code>adminhtml/catalog_product_edit_tab_upsell</code>类型，继承自 <code>Mage_Adminhtml_Block_Widget_Grid</code>。所以它创建了一个表格。第二个子Block <code>adminhtml/widget_grid_serializer</code> 是 <code>adminhtml/widget_grid_serializer</code> 类型，此类型是序列化Block。就像我们之前提到的，序列化Block是会添加到表格Block后面。</p>

<p>在XML布局文件中，拿序列化Block打比方，<code>方法 initSerializerBlock有如下几个参数:</code></p>

<ol>
<li>grid_block_name: 在布局文件中定义表格Block的名字，在我们的例子中叫作 <code>catalog.product.edit.tab.upsell</code>.</li>
<li>dta_callback: 该参数定义了一个方法，用来取到已选中的数据，并填写在表格Block里。</li>
<li>hidden_input_name: 隐藏域，从POST表单中取得提交的值。在我们的例子里是 links[upsell]。</li>
<li>reload_param_name: 该参数定义了当表格Block通过AJAX分页/过滤/排序等操作时，checkbox的表单名，在我们的例子里是 <code>products_upsell</code>。</li>
</ol>


<p>当序列化Block初始化的时候，它会调用在 data_callback 里定义的方法用来得到初始数据，填入表格Block。在我们的例子中，这个方法为 <code>getSelectedUpsellProducts()</code>。下面便是追加销售表格Block里的相关代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public function getSelectedUpsellProducts()
</span><span class='line'>{
</span><span class='line'>    $products = array();
</span><span class='line'>    foreach (Mage::registry('current_product')-&gt;getUpSellProducts() as $product) {
</span><span class='line'>        $products[$product-&gt;getId()] = array('position' =&gt; $product-&gt;getPosition());
</span><span class='line'>    }
</span><span class='line'>    return $products;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里，该方法返回所有已经存储了的追加销售产品。序列化JS对象把这个返回值存到序列化元素里。基本上，当我们的表格第一次加载的时候，序列化把所有存储在数据库里的数据标记为选中。</p>

<p>在表格Block中，受保护方法(protected)_prepareCoumns()用来定义列。那么追加销售表格Block的第一列就标记为checkbox:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$this-&gt;addColumn('in_products', array(
</span><span class='line'>  'header_css_class' =&gt; 'a-center',
</span><span class='line'>  'type' =&gt; 'checkbox',
</span><span class='line'>  'name' =&gt; 'in_products',
</span><span class='line'>  'values' =&gt; $this-&gt;_getSelectedProducts(),
</span><span class='line'>  'align' =&gt; 'center',
</span><span class='line'>  'index' =&gt; 'entity_id'
</span><span class='line'>));</span></code></pre></td></tr></table></div></figure>


<p>这里，类型(type)被定义为 <code>checkbox</code>，所以说每一行的这一列将会被显示checkbox。values定义了checkbox的值，以此类推。产品ID对应的checkboxs应该被选中。这里<code>$this-&gt;_getSelectedProducts()</code>方法用来取得选中的数据。</p>

<p>在追加销售产品Block里面还有一个方法 <code>getGridUrl()</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public function getGridUrl() {
</span><span class='line'>  return $this-&gt;_getData('grid_url') ? $this-&gt;_getData('grid_url') : $this-&gt;getUrl('*/*/upsellGrid', array('_current'=&gt;true));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>该方法定义了通过AJAX进行诸如分页，排序，过滤的操作时调用的URL。这个URL应该仅仅只是返回表格Block，而不会包含另外其它的Block，比如说是序列化Block。</p>

<p>该URL里面方法的实体如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public function upsellGridAction() {
</span><span class='line'>  $this-&gt;_initProduct();
</span><span class='line'>  $this-&gt;loadLayout();
</span><span class='line'>  $this-&gt;getLayout()-&gt;getBlock('catalog.product.edit.tab.upsell')
</span><span class='line'>  -&gt;setProductsUpsell($this-&gt;getRequest()-&gt;getPost('products_upsell', null));
</span><span class='line'>  $this-&gt;renderLayout();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>该方法对应的布局XML如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;adminhtml_catalog_product_upsellgrid&gt;
</span><span class='line'>  &lt;block type="core/text_list" name="root"&gt;
</span><span class='line'>      &lt;block type="adminhtml/catalog_product_edit_tab_upsell" name="catalog.product.edit.tab.upsell"/&gt;
</span><span class='line'>  &lt;/block&gt;
</span><span class='line'>&lt;/adminhtml_catalog_product_upsellgrid&gt;</span></code></pre></td></tr></table></div></figure>


<p>序列化Block添加了一个隐藏域名为<code>hidden_input_name</code>。当用户选择了任意一行，序列化数据将会被存储到该隐藏域。当用户浏览下/上一页，排序或是过滤数据时，表格通过AJAX加载，选中的数据作为名为<code>reload_param_name</code>的参数通过AJAX来传递。<code>reload_param_name</code>这里是设为<code>products_upsell</code>。在之前提到的方法<code>upsellGridAction()</code>里，POST提交过来的<code>products_upsell</code>是通过<code>setProductsUpsell()</code>方法传递和取得的，并显示在追加销售Blcok实例里。所以说，调用<code>getProductsUpsell()</code>方法将会返回之前选中的数据。</p>

<p>我之前有提到过<code>$this-&gt;_getSelectedProducts()</code>是用来得到选中的数据。下面是该方法的内容:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protected function _getSelectedProducts() {
</span><span class='line'>  $products = $this-&gt;getProductsUpsell();
</span><span class='line'>  if (!is_array($products)) {
</span><span class='line'>      $products = array_keys($this-&gt;getSelectedUpsellProducts());
</span><span class='line'>  }
</span><span class='line'>  return $products;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>之前有提到过，可以通过调用追加销售Block实例里的<code>getProductsUpsell()</code>方法来得到选中的数据。在这个方法里，首先试着通过调用这个方法取得数据。但是在我们的例子里，我们正在试图编辑一个产品，并且，在点击追加销售产品标签后，右侧内容加载以来，我们没有做任何改动，这个表格应该显示数据库里已经保存过的数据为选中。不管怎么说，如果没有选过任何产品，表格会通过调用<code>$this-&gt;getSelectedUpsellProducts()</code>来取得之前保存过的数据。</p>

<p>最后，当产品表单提交后，可以通过POST对象的<code>hidden_input_name</code>来取得选中的数据，在我们的例子里是<code>links[upsell]</code>。这个数据仍然是序例化格式的，Magento提供了一个Helper方法来解码这个数据: <code>Mage::helper('adminhtml/js')-&gt;decodeGridSerializedInput()</code>。</p>

<p>产品控制器在执行真正的保存操作之前会调用<code>_initSave()</code>方法。这个方法就是用来解码序例化数据:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$links = $this-&gt;getRequest()-&gt;getPost('links');
</span><span class='line'>…
</span><span class='line'>if ( isset($links['upsell']) && !$product-&gt;getUpsellReadonly() ) {
</span><span class='line'>  $product-&gt;setUpsellLinkData(Mage::helper('adminhtml/js')-&gt;decodeGridSerializeInput($links['upsell']));`</span></code></pre></td></tr></table></div></figure>


<p>最后，总结一下，完整的表格序列化Block执行过程按顺序如下:
1. 初始化，表格和序例华Block加载。
2. 当序例化Block初始完成后，会加载已保存的数据，并将它以序例化格式存在一个隐藏域中，并以选中的形式显示在表格Block里。
3. 用户执行的任何修改都将同时在隐藏域里反应出来。
4. 分页/排序/过滤等操作只会加载表格，而不是整个序例华Block，这样我们的数据就不会丢失。
5. 当重新载入的时候，选中的数据会通过AJAX以POST的方式传递。
6. 表格Block会试着从POST里取得数据，如果没有，会取得数据库中已经保存过的数据。
7. 当表单提交后，选中的数据以序例华的方式传递。
8. 最后，解码选中的数据并 存储到数据里。</p>

<h3>总结</h3>

<p>在这篇文章里，我们拿追加销售产品作为例子来分析怎么组合使用表格和序例化Block来作为传统多选框的替代方案。在该系例的下一篇文章里，我将会描述更多关于表格序例化的高级功能，这些功能可以创建更大，用户界面更友好的自定义widgets。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Magento Widget Form Container 错误]]></title>
    <link href="http://billsion.github.io/blog/2013/06/02/magento-widget-form-container-problem/"/>
    <updated>2013-06-02T20:38:00+08:00</updated>
    <id>http://billsion.github.io/blog/2013/06/02/magento-widget-form-container-problem</id>
    <content type="html"><![CDATA[<p>当我在后台创建一个表单里，出现了下面这个错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Fatal error: Call to a member function setData() on a non-object in app/code/core/Mage/Adminhtml/Block/Widget/Form/Container.php on line 129</span></code></pre></td></tr></table></div></figure>


<p>我很花了些工夫来找出问题，在GOOGLE了一通后，我发现实际情况是Magento没有找到对应的 Form Container。</p>

<p>在Magento后台的开发过程是，Widget Forms 被用来编辑表单实体(entity)，你需要 Mage_Adminhtml_Block_Widget_Form_Container 来包含 Mage_Adminhtml_Block_Widget_Form ( 还有tabs )。</p>

<p>通常情况下，Container 要找到一个 Form，它需要三个属性，像下面这样：</p>

<ul>
<li>protected $_blockGroup = &#8216;moduleName&#8217;;</li>
<li>protected $_controller = &#8216;pathToModuleController&#8217;;</li>
<li>protected $_mode = &#8216;edit&#8217;;</li>
</ul>


<p>这几个属性用来寻找表单，在父类中，真实情况是这样的：
<code>$this-&gt;getLayout()-&gt;createBlock($this-&gt;_blockGroup . '/' . $this-&gt;_controller . '_' . $this-&gt;_mode . '_form')</code></p>

<p>在我的例子里，它将会是这样&#8221;moduleName/pathToModuleController_edit_form&#8221;，这样就创建了一个Block实例。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Magento后台开启Hint]]></title>
    <link href="http://billsion.github.io/blog/2013/05/28/enable-template-hints-in-magento-backend/"/>
    <updated>2013-05-28T11:56:00+08:00</updated>
    <id>http://billsion.github.io/blog/2013/05/28/enable-template-hints-in-magento-backend</id>
    <content type="html"><![CDATA[<p>经常写Magento的人对前台的Hints并不陌生，开启了Hints之后，对Block的查找很方便，特别是那些嵌套得很厉害的页面来讲。但是很少有人知道其实后台也可以开启这个功能，不过不是在管理页面打开，需要直接在表里面添加一条数据，像下面这样。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>`INSERT INTO `core_config_data` (`scope`, `scope_id`, `path`, `value`)
</span><span class='line'>       VALUES ('websites', '0', 'dev/debug/template_hints', '1');`</span></code></pre></td></tr></table></div></figure>


<p>1表示开启，0表示关闭，当然，你把这条记录删掉也行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Magento邮件模板中添加自定义变量]]></title>
    <link href="http://billsion.github.io/blog/2013/04/15/add-custom-variables-in-email-template/"/>
    <updated>2013-04-15T10:27:00+08:00</updated>
    <id>http://billsion.github.io/blog/2013/04/15/add-custom-variables-in-email-template</id>
    <content type="html"><![CDATA[<p>这几天在Magento开发上遇到一个问题，就是在Email模板中显示自定义的变量。</p>

<p>很简单的扩展：</p>

<ol>
<li>找到当前需要修改的Email模板，模板放在 <code>{ $website_root }/app/locale/{ $language }/template/email/</code></li>
<li>找到对应的模块，从相应的模版名字可以看出来。比如说 <code>order_new.html</code> 是 <code>Mage_Sales_Model_Order</code> 模块。</li>
<li>找到发送邮件的方法，<code>order_new.html</code> 对应的发送邮件方法是 <code>sendNewOrderEmail</code></li>
<li>在该方法中查找 <code>$mailer-&gt;setTemplateParams</code>的方法，里面的参数就是将会在页面中显示的变量/对象。</li>
</ol>


<p>稍微修改下就成了，就这么简单。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Magento中合并JavaScript一定会提升访问速度吗]]></title>
    <link href="http://billsion.github.io/blog/2013/04/14/zai-magentozhong-he-bing-javascript-ding-hui-ti-sheng-fang-wen-su-du-ma/"/>
    <updated>2013-04-14T15:53:00+08:00</updated>
    <id>http://billsion.github.io/blog/2013/04/14/zai-magentozhong-he-bing-javascript-ding-hui-ti-sheng-fang-wen-su-du-ma</id>
    <content type="html"><![CDATA[<p>本文译自<a href="http://fishpig.co.uk/blog/why-you-shouldnt-merge-javascript-in-magento.html">fishpig</a></p>

<p>很多人 - 包括我自己 - 认为把所有的独立JS文件合并成一个文件是一个提升前端速度不错的的方法。道理很简单，合并文件，自然就减少了浏览器在加载页面时的请求数量，好处自然就是缩短完成请求的时间，让页面载入更快。让我们通过Magento中的一个例子来看看它是怎么处理的。</p>

<p>设想一下你刚刚在后台开启了Javascript 合并功能，这时有人来浏览你的网站。Magento将整理所有的XML布局文件并且判断在首页应该包含哪些Javascript。所有的这些被请求的JS文件都会被合并成一个单一文件并且以MD5加密的文件名来存储，此新文件，比如说是 f0eb853c09ba3e46ad21fb89b8d57626.js，只为那些浏览过该网页并保存在浏览器缓存中的用户服务。</p>

<p>接下来，用户点击一个链接进入到目录页面。这时，Magento会再一次整理所有的XML布局文件并且判断目录页面会用到哪些JS文件。此时，Magento 会发现在首页用到的JS文件同样也会在目前的页面中用到，这一次不同，浏览器知道自己已经下载了这个文件，便不会再次下载。相反，文件会从用户的缓存中加载以节省时间，带宽和CPU资源！</p>

<p>目前为止，一切都运行的好好的，我们通过减少对服务器的请求让页面变快了，但是……</p>

<p>接下来，用户被一个产品吸引，于是点击进去到详细页面浏览。再一次，Magento判定哪些在布局文件(XML)里的JS文件需要被加载。此时，Magento发现会用到首页已经加载的JS文件，当然还有两个新文件需要加载。但是已有的合并文件中不存在这样的内容，于是Magento会新建一个名为139f9771ba2ba0cae754978fab4a3c35.js的文件。粗略估计该文件的80％和首页的脚本文件一样，已经被用户下载并缓存了。但还是会迫使用户下载该文件全部内容！虽然此文件的80％已经缓存了，但用户的浏览器完全不知情，还是会下载该文件并缓存！</p>

<p>合并JS文件的初衷是为了减少页面的加载时间，但是在上述场景里，用户被迫再次下载一大块代码！这样做毫无疑问增加了页面载入时间（下载并不需要下载的JS文件，差不多有～40kb），这样做的结果反而和合并文件的初衷相违被。</p>

<p>让我们来看看如果不开启合并JS会怎样。</p>

<p>当用户第一次访问首页时，之前合并过的JS文件在这次请求中会被单独下载。虽然这些文件整个大小和之前合并文件的大小一致，但是请求时间会比较长，因为文件都是被单独请求/下载/缓存的。</p>

<p>接下来，用户访问分类页面，这个页面用到了和之前在浏览首页时下载/缓存过的文件。结果就是此页面加载的时间和之前合并JS后加载页面用的时间一样。在这两种情况下，所有需要用到的JS文件都已经下载下来并且已经缓存了，总而言之，浏览器可以不管这些文件了。</p>

<p>最后，用户访问了产品页面，此页面把之前在首页和分类页面加载过的文件，除此之外加载两个新文件。这些文件已经在首页或是分类页面缓存过了，所以浏览器直接跳过下载，并且缓存两个之前并没有访问过的文件！同时，Magento首页用到的文件占到了产品页面里JS文件数量的80%。当关闭合并选项后，我们就直接的下载了剩下的20%。在之前的合并例子里，等于说是整个重新下载了一遍！</p>

<p>问题就是用户在访问不同页面时，JS文件也会有不同的组合，这样难免在一个页面中漏掉某一个JS，每当这种情况发生时，用户就会被强迫下载之前已经下载过的文件，并以另一个文件名保存。</p>

<h3>怎么办?</h3>

<p>当Magento的合并功能有问题时，就只能动手作些小修改了。</p>

<p>在Magento里面，Javascript是通过XML文件里的Head block或是数组来循环添加到HTML里。我们建议加一个额外的参数在你的Javascript包含代码里，看下面的代码：</p>

<pre><code>&lt;default&gt;
    &lt;reference name="head"&gt;
        &lt;action method="addJs"&gt;&lt;script&gt;prototype/prototype.js&lt;/script&gt;&lt;group&gt;global&lt;/group&gt;&lt;/action&gt;
        &lt;action method="addJs"&gt;&lt;script&gt;scriptaculous/builder.js&lt;/script&gt;&lt;group&gt;global&lt;/group&gt;&lt;/action&gt;
        &lt;action method="addJs"&gt;&lt;script&gt;scriptaculous/effects.js&lt;/script&gt;&lt;group&gt;global&lt;/group&gt;&lt;/action&gt;
        &lt;action method="addJs"&gt;&lt;script&gt;varien/form.js&lt;/script&gt;&lt;group&gt;global&lt;/group&gt;&lt;/action&gt;
    &lt;/reference&gt;
&lt;/default&gt;
&lt;catalog_product_view&gt;
    &lt;reference name="head"&gt;
        &lt;action method="addJs"&gt;&lt;script&gt;varien/product.js&lt;/script&gt;&lt;group&gt;product&lt;/group&gt;&lt;/action&gt;
        &lt;action method="addJs"&gt;&lt;script&gt;varien/configurable.js&lt;/script&gt;&lt;group&gt;product&lt;/group&gt;&lt;/action&gt;
    &lt;/reference&gt;
&lt;/catalog_product_view&gt;
</code></pre>

<p>注意到了新参数 group 吗？和合并所有的Javascript到一个文件不一样，group参数将会判断哪些Javascript文件需要合并。上面的代码将会为产品页面生成两个分开的合并文件: 一个是包含在首页里用到的全局Javascript，一个是包含只会在产品页面里用到的文件。虽然这样做会导制额外的请求，但这样做还是会节省时间，因为不用再去下载已经在首页下载过的文件！如果在整站中用到这个小技巧，每一个Javascript将只会被下载一次。</p>
]]></content>
  </entry>
  
</feed>
